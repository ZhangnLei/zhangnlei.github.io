<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>张念磊的博客</title>
  
  <subtitle>我</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-07-25T06:38:16.333Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>张念磊</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>后端开发 - 记一次生产问题定位</title>
    <link href="http://yoursite.com/2020/07/25/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91-%E8%AE%B0%E4%B8%80%E6%AC%A1%E7%94%9F%E4%BA%A7%E9%97%AE%E9%A2%98%E5%AE%9A%E4%BD%8D/"/>
    <id>http://yoursite.com/2020/07/25/后端开发-记一次生产问题定位/</id>
    <published>2020-07-25T04:03:54.000Z</published>
    <updated>2020-07-25T06:38:16.333Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>一个服务上线生产之后两天出现了三次问题</p><p>详细征兆如下：</p><ol><li>刚出现此问题时，浏览器的一个请求发过去，开发者工具network一栏显示该请求状态一直是padding，会持续几分钟。</li><li>过几分钟后发给该服务的所有请求都会立即返回500，提示信息为</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">timestamp: 1595658988848</span><br><span class="line">status: 500</span><br><span class="line">error: "Internal Server Error"</span><br><span class="line">exception: "com.netflix.zuul.exception.ZuulException"</span><br><span class="line">message: "GENERAL"</span><br></pre></td></tr></table></figure><ol start="3"><li><p>后台服务不会产生任何日志（日志级别info，服务正常时打印请求体和一些自定义的日志信息）；</p></li><li><p>网关服务也没有打印相关的请求日志（没有实时监测日志，过时定位日志分析的，待确认）</p></li><li><p>通过重启服务可暂时解决该问题，不过一段时间后可能会复现。</p></li></ol><h2 id="可能的原因"><a href="#可能的原因" class="headerlink" title="可能的原因"></a>可能的原因</h2><p>前提：近期用户增多，有49家机构在使用该功能模块。</p><ol><li>服务器线程爆了：该服务器一共部署了31个微服务，还有一些对外提供的的其他服务，服务的总线程数量超过计算机的最大线程数量。</li><li>服务器内存不够：服务器内存为32GB，现有未使用1GB（每个服务的运行内存设置为300M/512M/1G）。但服务日志没有爆出内存溢出异常，不能断定是该问题。</li><li>编写的代码异常导致，但异常时服务不产生日志，无法定位问题。以前也会有此问题，程序异常，后台返回的异常原因是null，可能是该服务的config配置有误，没有准确捕捉并返回异常信息。</li></ol><h2 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h2><ol><li>减小其他服务启动时配置的内存大小，使服务器内存处于健康状态 (已使用该方法，能暂时解决问题)</li><li>限制每个微服务的线程数量，使其不能超过计算机的最大线程数</li><li>为服务添加合理的全局异常捕获机制。</li><li>找同事协助分析解决</li></ol><p>补充 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">环境信息：</span><br><span class="line">Linux：Redhat</span><br><span class="line">微服务框架：SpringCloud</span><br><span class="line">服务注册：eureka</span><br><span class="line">网关服务：gateway</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[toc]&lt;/p&gt;
&lt;h2 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h2&gt;&lt;p&gt;一个服务上线生产之后两天出现了三次问题&lt;/p&gt;
&lt;p&gt;详细征兆如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;刚
      
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 153. 寻找旋转排序数组中的最小值</title>
    <link href="http://yoursite.com/2020/07/22/LeetCode-153-%E5%AF%BB%E6%89%BE%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BC/"/>
    <id>http://yoursite.com/2020/07/22/LeetCode-153-寻找旋转排序数组中的最小值/</id>
    <published>2020-07-22T05:27:15.000Z</published>
    <updated>2020-07-22T05:41:53.167Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p> <a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/" target="_blank" rel="noopener">153. 寻找旋转排序数组中的最小值</a></p><p>假设按照升序排序的数组在预先未知的某个点上进行了旋转。</p><p>( 例如，数组 <code>[0,1,2,4,5,6,7]</code> 可能变为 <code>[4,5,6,7,0,1,2]</code> )。</p><p>请找出其中最小的元素。</p><p>你可以假设数组中不存在重复元素。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [3,4,5,1,2]</span><br><span class="line">输出: 1</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [4,5,6,7,0,1,2]</span><br><span class="line">输出: 0</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [0,1,2,4,5,6,7]</span><br><span class="line">输出: 0</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p><code>思路1:暴力法</code></p><p>从左到右遍历数组，找出最小的数字</p><p><code>思路2：</code></p><h2 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>更多详细代码见我的代码仓库</p><p><a href="https://github.com/ZhangnLei/java-base/tree/master/src/main/java/mrzhang/leecode" target="_blank" rel="noopener">https://github.com/ZhangnLei/java-base/tree/master/src/main/java/mrzhang/leecode</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[toc]&lt;/p&gt;
&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt; &lt;a href=&quot;https://leetcode-cn.com/problems/find-minimum-i
      
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 154. 寻找旋转排序数组中的最小值 II</title>
    <link href="http://yoursite.com/2020/07/22/LeetCode-154-%E5%AF%BB%E6%89%BE%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BC-II/"/>
    <id>http://yoursite.com/2020/07/22/LeetCode-154-寻找旋转排序数组中的最小值-II/</id>
    <published>2020-07-22T04:52:35.000Z</published>
    <updated>2020-07-22T05:34:59.541Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p> <a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array-ii/" target="_blank" rel="noopener">154. 寻找旋转排序数组中的最小值 II</a></p><p>假设按照升序排序的数组在预先未知的某个点上进行了旋转。</p><p>( 例如，数组 <code>[0,1,2,4,5,6,7]</code> 可能变为 <code>[4,5,6,7,0,1,2]</code> )。</p><p>请找出其中最小的元素。</p><p>注意数组中可能存在重复的元素。</p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,3,5]</span><br><span class="line">输出: 1</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [2,2,2,0,1]</span><br><span class="line">输出: 0</span><br></pre></td></tr></table></figure><p><strong>说明：</strong></p><ul><li>这道题是 <a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/description/" target="_blank" rel="noopener">寻找旋转排序数组中的最小值</a> 的延伸题目。</li><li>允许重复会影响算法的时间复杂度吗？会如何影响，为什么？</li></ul><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h2 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>更多详细代码见我的代码仓库</p><p><a href="https://github.com/ZhangnLei/java-base/tree/master/src/main/java/mrzhang/leecode" target="_blank" rel="noopener">https://github.com/ZhangnLei/java-base/tree/master/src/main/java/mrzhang/leecode</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[toc]&lt;/p&gt;
&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt; &lt;a href=&quot;https://leetcode-cn.com/problems/find-minimum-i
      
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 167. 两数之和 II - 输入有序数组</title>
    <link href="http://yoursite.com/2020/07/20/LeetCode-167-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C-II-%E8%BE%93%E5%85%A5%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84/"/>
    <id>http://yoursite.com/2020/07/20/LeetCode-167-两数之和-II-输入有序数组/</id>
    <published>2020-07-20T05:17:31.000Z</published>
    <updated>2020-07-22T05:35:04.939Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p> <a href="https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/" target="_blank" rel="noopener">167. 两数之和 II - 输入有序数组</a></p><p>给定一个已按照<strong><em>升序排列\</em></strong> 的有序数组，找到两个数使得它们相加之和等于目标数。</p><p>函数应该返回这两个下标值 index1 和 index2，其中 index1 必须小于 index2<em>。</em></p><p><strong>说明:</strong></p><ul><li>返回的下标值（index1 和 index2）不是从零开始的。</li><li>你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。</li></ul><p><strong>示例:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: numbers &#x3D; [2, 7, 11, 15], target &#x3D; 9</span><br><span class="line">输出: [1,2]</span><br><span class="line">解释: 2 与 7 之和等于目标数 9 。因此 index1 &#x3D; 1, index2 &#x3D; 2 。</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p><code>思路1：暴力法</code></p><p>两个for循环嵌套，当target - num[i] == num[j]时推出for循环，返回 res[] = [i+1, j+1]</p><p><code>思路2：二分查找法</code></p><p>利用<em>升序数组</em>这一条件，固定一个值i，然后去数组里查找j，应为数组是升序的，查找时可使用二分查找法。</p><p><code>思路3：双指针法</code></p><p>两个指针分别指向头和尾，当两数之和等于target时，返回结果；两数之和大于target时，尾指针前移；两数之和小于target时，首指针后移。移动后再次判断，直至找到唯一解。</p><h2 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution167</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>  `思路1：暴力法`</span></span><br><span class="line"><span class="comment"> * 两个for循环嵌套，当target - num[i] == num[j]时推出for循环，返回 res[] = [i+1, j+1]</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] twoSum1(<span class="keyword">int</span>[] numbers, <span class="keyword">int</span> target) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numbers.length; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; numbers.length; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (target - numbers[i] == numbers[j]) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i+<span class="number">1</span>, j+<span class="number">1</span>&#125;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>  `思路2：二分查找法`</span></span><br><span class="line"><span class="comment"> * 利用*升序数组*这一条件，固定一个值i，然后去数组里查找j，应为数组是升序的，查找时可使用二分查找法。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] twoSum2(<span class="keyword">int</span>[] numbers, <span class="keyword">int</span> target) &#123;</span><br><span class="line"><span class="keyword">int</span> res[] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numbers.length; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> index2 = getIndexBetween(numbers, i + <span class="number">1</span>, numbers.length -<span class="number">1</span>, target - numbers[i]);</span><br><span class="line"><span class="keyword">if</span> (index2 &gt; -<span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i+<span class="number">1</span>, index2 + <span class="number">1</span>&#125;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 二分法查找元素</span></span><br><span class="line"><span class="comment"> * 查找区间为 (begin, nums.length-1]</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getIndexBetween</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> begin, <span class="keyword">int</span> end, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> mid = (begin + end) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (begin &gt; end) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line"><span class="keyword">return</span> mid;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line"><span class="keyword">return</span> getIndexBetween(nums, begin, mid -<span class="number">1</span>, target);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> getIndexBetween(nums, mid + <span class="number">1</span>, end, target);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>  `思路3：双指针法`</span></span><br><span class="line"><span class="comment"> * 两个指针分别指向头和尾，当两数之和等于target时，返回结果；两数之和大于target时，尾指针前移；两数之和小于target时，首指针后移。移动后再次判断，直至找到唯一解。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] twoSum3(<span class="keyword">int</span>[] numbers, <span class="keyword">int</span> target) &#123;</span><br><span class="line"><span class="keyword">int</span> res[] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> left = <span class="number">0</span>, right = numbers.length -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line"><span class="keyword">int</span> sum = numbers[left] + numbers[right];</span><br><span class="line"><span class="keyword">if</span> (sum == target) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;left + <span class="number">1</span>, right + <span class="number">1</span>&#125;;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &lt; target) &#123;</span><br><span class="line">left += <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">right -= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更多详细代码见我的代码仓库</p><p><a href="https://github.com/ZhangnLei/java-base/tree/master/src/main/java/mrzhang/leecode" target="_blank" rel="noopener">https://github.com/ZhangnLei/java-base/tree/master/src/main/java/mrzhang/leecode</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[toc]&lt;/p&gt;
&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt; &lt;a href=&quot;https://leetcode-cn.com/problems/two-sum-ii-inp
      
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>后端开发 - Java反射获取类的所有的属性和父类的所有属性</title>
    <link href="http://yoursite.com/2020/07/16/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91-Java%E5%8F%8D%E5%B0%84%E8%8E%B7%E5%8F%96%E7%B1%BB%E7%9A%84%E6%89%80%E6%9C%89%E7%9A%84%E5%B1%9E%E6%80%A7%E5%92%8C%E7%88%B6%E7%B1%BB%E7%9A%84%E6%89%80%E6%9C%89%E5%B1%9E%E6%80%A7/"/>
    <id>http://yoursite.com/2020/07/16/后端开发-Java反射获取类的所有的属性和父类的所有属性/</id>
    <published>2020-07-16T02:05:26.000Z</published>
    <updated>2020-07-16T02:47:35.836Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>想获取一个类的所有属性和父类的所有属性</p><p>看一下官方文档中关于获取类的属性的两个方法：</p><ol><li><h3 id="getDeclaredFields"><a href="#getDeclaredFields" class="headerlink" title="getDeclaredFields"></a>getDeclaredFields</h3></li></ol><p>返回一个字段对象数组，反映由这个类对象表示的类或接口声明的所有字段。这包括公共、受保护、默认(包)访问和私有字段，但不包括继承字段。</p><ol start="2"><li><h3 id="getFields"><a href="#getFields" class="headerlink" title="getFields"></a>getFields</h3></li></ol><p>返回一个包含“字段”对象的数组，该数组反映由这个“类”对象表示的类或接口的所有可访问的公共字段。</p><p>这两个方法都不能获取所有属性，那我们自己写一个方法。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>首先构建一个列表用来存放所有的属性；</p><p>获取使用getDeclaredFields()函数获取本类内部的所有属性，并addAll()到列表中；</p><p>使用clazz.getSuperclass()方法获取父类，然后获取父类中的所有属性，将其添加到列表中；</p><p>最后递归检查父类是否有父类，直到获取不到父类；</p><h2 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取本类及其父类的属性的方法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> clazz 当前类对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 字段数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Field[] getAllFields(Class&lt;?&gt; clazz) &#123;</span><br><span class="line">List&lt;Field&gt; fieldList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">while</span> (clazz != <span class="keyword">null</span>)&#123;</span><br><span class="line">fieldList.addAll(<span class="keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(clazz.getDeclaredFields())));</span><br><span class="line">clazz = clazz.getSuperclass();</span><br><span class="line">&#125;</span><br><span class="line">Field[] fields = <span class="keyword">new</span> Field[fieldList.size()];</span><br><span class="line"><span class="keyword">return</span> fieldList.toArray(fields);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Field[] clzFields = getAllFields(AppSysUnitVo<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"><span class="keyword">for</span> (Field clzField : clzFields) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (!clzField.isAccessible()) &#123;</span><br><span class="line">clzField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(clzField.getName());</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更多详细代码见我的代码仓库</p><p><a href="https://github.com/ZhangnLei/java-base/tree/master/src/main/java/mrzhang/sy" target="_blank" rel="noopener">https://github.com/ZhangnLei/java-base/tree/master/src/main/java/mrzhang/sy</a></p><h2 id="官方文档："><a href="#官方文档：" class="headerlink" title="官方文档："></a>官方文档：</h2><h3 id="getDeclaredFields-1"><a href="#getDeclaredFields-1" class="headerlink" title="getDeclaredFields"></a>getDeclaredFields</h3><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public Field[] getDeclaredFields()</span><br><span class="line">                          throws SecurityException</span><br></pre></td></tr></table></figure><p>Returns an array of <code>Field</code> objects reflecting all the fields declared by the class or interface represented by this <code>Class</code> object. This includes public, protected, default (package) access, and private fields, but excludes inherited fields.</p><p>If this <code>Class</code> object represents a class or interface with no declared fields, then this method returns an array of length 0.</p><p>If this <code>Class</code> object represents an array type, a primitive type, or void, then this method returns an array of length 0.</p><p>The elements in the returned array are not sorted and are not in any particular order.</p><ul><li><p><strong>Returns:</strong></p><p>the array of <code>Field</code> objects representing all the declared fields of this class</p></li><li><p><strong>Throws:</strong></p><p><code>SecurityException</code> - If a security manager, <em>s</em>, is present and any of the following conditions is met:the caller’s class loader is not the same as the class loader of this class and invocation of <a href="dfile:///Users/zhangdabao/Library/Application Support/Dash/DocSets/Java_SE8/Java.docset/Contents/Resources/Documents/java/lang/SecurityManager.html#checkPermission-java.security.Permission-"><code>s.checkPermission</code></a> method with<code>RuntimePermission(&quot;accessDeclaredMembers&quot;)</code> denies access to the declared fields within this classthe caller’s class loader is not the same as or an ancestor of the class loader for the current class and invocation of <a href="dfile:///Users/zhangdabao/Library/Application Support/Dash/DocSets/Java_SE8/Java.docset/Contents/Resources/Documents/java/lang/SecurityManager.html#checkPackageAccess-java.lang.String-"><code>s.checkPackageAccess()</code></a> denies access to the package of this class</p></li><li><p><strong>Since:</strong></p><p>JDK1.1</p></li><li><p><strong>See The Java™ Language Specification:</strong></p><p>8.2 Class Members, 8.3 Field Declarations</p></li></ul></blockquote><h3 id="getFields-1"><a href="#getFields-1" class="headerlink" title="getFields"></a>getFields</h3><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public Field[] getFields()</span><br><span class="line">                  throws SecurityException</span><br></pre></td></tr></table></figure><p>Returns an array containing <code>Field</code> objects reflecting all the accessible public fields of the class or interface represented by this <code>Class</code> object.</p><p>If this <code>Class</code> object represents a class or interface with no no accessible public fields, then this method returns an array of length 0.</p><p>If this <code>Class</code> object represents a class, then this method returns the public fields of the class and of all its superclasses.</p><p>If this <code>Class</code> object represents an interface, then this method returns the fields of the interface and of all its superinterfaces.</p><p>If this <code>Class</code> object represents an array type, a primitive type, or void, then this method returns an array of length 0.</p><p>The elements in the returned array are not sorted and are not in any particular order.</p><ul><li><p><strong>Returns:</strong></p><p>the array of <code>Field</code> objects representing the public fields</p></li><li><p><strong>Throws:</strong></p><p><code>SecurityException</code> - If a security manager, <em>s</em>, is present and the caller’s class loader is not the same as or an ancestor of the class loader for the current class and invocation of <a href="dfile:///Users/zhangdabao/Library/Application Support/Dash/DocSets/Java_SE8/Java.docset/Contents/Resources/Documents/java/lang/SecurityManager.html#checkPackageAccess-java.lang.String-"><code>s.checkPackageAccess()</code></a> denies access to the package of this class.</p></li><li><p><strong>Since:</strong></p><p>JDK1.1</p></li><li><p><strong>See The Java™ Language Specification:</strong></p><p>8.2 Class Members, 8.3 Field Declarations</p></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[toc]&lt;/p&gt;
&lt;h2 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h2&gt;&lt;p&gt;想获取一个类的所有属性和父类的所有属性&lt;/p&gt;
&lt;p&gt;看一下官方文档中关于获取类的属性的两个方法：&lt;/p&gt;
&lt;ol
      
    
    </summary>
    
    
      <category term="反射" scheme="http://yoursite.com/tags/%E5%8F%8D%E5%B0%84/"/>
    
      <category term="获取父类的所有属性" scheme="http://yoursite.com/tags/%E8%8E%B7%E5%8F%96%E7%88%B6%E7%B1%BB%E7%9A%84%E6%89%80%E6%9C%89%E5%B1%9E%E6%80%A7/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 96. 不同的二叉搜索树</title>
    <link href="http://yoursite.com/2020/07/15/LeetCode-96-%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
    <id>http://yoursite.com/2020/07/15/LeetCode-96-不同的二叉搜索树/</id>
    <published>2020-07-15T05:10:38.000Z</published>
    <updated>2020-07-16T06:47:50.718Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p> <a href="https://leetcode-cn.com/problems/unique-binary-search-trees/" target="_blank" rel="noopener">96. 不同的二叉搜索树</a></p><p>难度中等663收藏分享切换为英文关注反馈</p><p>给定一个整数 <em>n</em>，求以 1 … <em>n</em> 为节点组成的二叉搜索树有多少种？</p><p><strong>示例:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入: 3</span><br><span class="line">输出: 5</span><br><span class="line">解释:</span><br><span class="line">给定 n &#x3D; 3, 一共有 5 种不同结构的二叉搜索树:</span><br><span class="line"></span><br><span class="line">   1         3     3      2      1</span><br><span class="line">    \       &#x2F;     &#x2F;      &#x2F; \      \</span><br><span class="line">     3     2     1      1   3      2</span><br><span class="line">    &#x2F;     &#x2F;       \                 \</span><br><span class="line">   2     1         2                 3</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>设G(n)为n个节点组成二叉搜索树的个数，f(i)为以i为根节点二叉搜索树的个数<br>则有：G(n) = f(1) + f(2) + … + f(n);<br>又因为i的左侧有i-1个节点，右侧有n-i个节点，<br>则有：f(i) = G(i-1) <em> G(n-i);<br>结合上述两式可得：<br>G(n) = G(0) </em> G(n-1) + G(1) <em> G(n-2) + … + G(n-1) </em> G(0);</p><h2 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n + <span class="number">1</span>; i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; i + <span class="number">1</span>; j++) </span><br><span class="line">                dp[i] += dp[j-<span class="number">1</span>] * dp[i-j];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更多详细代码见我的代码仓库</p><p><a href="https://github.com/ZhangnLei/java-base/tree/master/src/main/java/mrzhang/leecode" target="_blank" rel="noopener">https://github.com/ZhangnLei/java-base/tree/master/src/main/java/mrzhang/leecode</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[toc]&lt;/p&gt;
&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt; &lt;a href=&quot;https://leetcode-cn.com/problems/unique-binary-
      
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="二叉搜索树" scheme="http://yoursite.com/tags/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
    
      <category term="公式法" scheme="http://yoursite.com/tags/%E5%85%AC%E5%BC%8F%E6%B3%95/"/>
    
      <category term="卡特兰数" scheme="http://yoursite.com/tags/%E5%8D%A1%E7%89%B9%E5%85%B0%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 350. 两个数组的交集 II</title>
    <link href="http://yoursite.com/2020/07/13/LeetCode-350-%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86-II/"/>
    <id>http://yoursite.com/2020/07/13/LeetCode-350-两个数组的交集-II/</id>
    <published>2020-07-13T05:31:15.000Z</published>
    <updated>2020-07-15T05:12:03.499Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/intersection-of-two-arrays-ii/" target="_blank" rel="noopener">350. 两个数组的交集 II</a></p><p>难度简单326收藏分享切换为英文关注反馈</p><p>给定两个数组，编写一个函数来计算它们的交集。</p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 &#x3D; [1,2,2,1], nums2 &#x3D; [2,2]</span><br><span class="line">输出：[2,2]</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 &#x3D; [4,9,5], nums2 &#x3D; [9,4,9,8,4]</span><br><span class="line">输出：[4,9]</span><br></pre></td></tr></table></figure><p><strong>说明：</strong></p><ul><li>输出结果中每个元素出现的次数，应与元素在两个数组中出现次数的最小值一致。</li><li>我们可以不考虑输出结果的顺序。</li></ul><p><strong><em>\</em>进阶\</strong>：**</p><ul><li>如果给定的数组已经排好序呢？你将如何优化你的算法？</li><li>如果 <em>nums1</em> 的大小比 <em>nums2</em> 小很多，哪种方法更优？</li><li>如果 <em>nums2</em> 的元素存储在磁盘上，磁盘内存是有限的，并且你不能一次加载所有的元素到内存中，你该怎么办？</li></ul><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p><code>我的思路：</code></p><p>维护两个hashMap，元素为key，出现的次数为value；最后遍历比较两个hashMap</p><p><code>LeetCode官方提供的思路1：</code></p><p>在我的思路上做了优化，只维护一个hashMap，遍历短的数组，生成hashMap，value增加；遍历第二个数组，取map中找是否存在元素，如存在则value-1，把key添加到结果中。很精妙！</p><p>(可选优化：value=0时把key删掉，每次getKey前判断map是否有key)</p><p><code>LeetCode官方提供的思路2：</code></p><p>先排序，然后使用两个指针做对比，两个指针指向的值相同时，记录元素，然后同时后移；两个指针指向的值不同时，数值小的指针往后移，任意一个数组完成后则停止。</p><h2 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>更多详细代码见我的代码仓库</p><p><a href="https://github.com/ZhangnLei/java-base/tree/master/src/main/java/mrzhang/leecode" target="_blank" rel="noopener">https://github.com/ZhangnLei/java-base/tree/master/src/main/java/mrzhang/leecode</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[toc]&lt;/p&gt;
&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/intersection-of
      
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 108. 有序数组转换二叉搜索树</title>
    <link href="http://yoursite.com/2020/07/11/LeetCode-108-%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E8%BD%AC%E6%8D%A2%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
    <id>http://yoursite.com/2020/07/11/LeetCode-108-有序数组转换二叉搜索树/</id>
    <published>2020-07-11T03:48:43.000Z</published>
    <updated>2020-07-11T04:12:27.730Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><h4 id="108-将有序数组转换为二叉搜索树"><a href="#108-将有序数组转换为二叉搜索树" class="headerlink" title="108. 将有序数组转换为二叉搜索树"></a><a href="https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/" target="_blank" rel="noopener">108. 将有序数组转换为二叉搜索树</a></h4><p>将一个按照升序排列的有序数组，转换为一棵高度平衡二叉搜索树。</p><p>本题中，一个高度平衡二叉树是指一个二叉树<em>每个节点</em> 的左右两个子树的高度差的绝对值不超过 1。</p><p><strong>示例:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">给定有序数组: [-10,-3,0,5,9],</span><br><span class="line"></span><br><span class="line">一个可能的答案是：[0,-3,9,-10,null,5]，它可以表示下面这个高度平衡二叉搜索树：</span><br><span class="line"></span><br><span class="line">      0</span><br><span class="line">     &#x2F; \</span><br><span class="line">   -3   9</span><br><span class="line">   &#x2F;   &#x2F;</span><br><span class="line"> -10  5</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h2 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> mrzhang.leecode;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zhangnianlei</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/7/7</span></span><br><span class="line"><span class="comment"> * 108. 将有序数组转换为二叉搜索树</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution108</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TreeNode <span class="title">sortedArrayToBST</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> dfs(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 递归的构建一棵二叉搜索树</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zhangnianlei</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/7/11</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@exception</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>: nums</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>: left</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>: right</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>: mrzhang.leecode.TreeNode</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@modifier</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> TreeNode <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (left &gt; right) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">TreeNode root = <span class="keyword">new</span> TreeNode(nums[mid]);</span><br><span class="line">root.left = dfs(nums, left, mid - <span class="number">1</span>);</span><br><span class="line">root.right = dfs(nums, mid + <span class="number">1</span>, right);</span><br><span class="line"><span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 编写一个main函数在本地检验</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zhangnianlei</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/7/11</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@exception</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>: args</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@modifier</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span>[] nums = &#123;-<span class="number">10</span>,-<span class="number">3</span>,<span class="number">0</span>,<span class="number">5</span>,<span class="number">9</span>&#125;;</span><br><span class="line">TreeNode root = sortedArrayToBST(nums);</span><br><span class="line">TreeNode.prePrint(root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更多详细代码见我的代码仓库</p><p><a href="https://github.com/ZhangnLei/java-base/tree/master/src/main/java/mrzhang/leecode" target="_blank" rel="noopener">https://github.com/ZhangnLei/java-base/tree/master/src/main/java/mrzhang/leecode</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[toc]&lt;/p&gt;
&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;h4 id=&quot;108-将有序数组转换为二叉搜索树&quot;&gt;&lt;a href=&quot;#108-将有序数组转换为二叉搜索树&quot; clas
      
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="二叉搜索树" scheme="http://yoursite.com/tags/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
    
      <category term="递归" scheme="http://yoursite.com/tags/%E9%80%92%E5%BD%92/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 109. 有序链表转换二叉搜索树</title>
    <link href="http://yoursite.com/2020/07/11/LeetCode-109-%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%E8%BD%AC%E6%8D%A2%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
    <id>http://yoursite.com/2020/07/11/LeetCode-109-有序链表转换二叉搜索树/</id>
    <published>2020-07-11T03:47:10.000Z</published>
    <updated>2020-07-11T04:12:22.470Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><h4 id="109-有序链表转换二叉搜索树"><a href="#109-有序链表转换二叉搜索树" class="headerlink" title="109. 有序链表转换二叉搜索树"></a><a href="https://leetcode-cn.com/problems/convert-sorted-list-to-binary-search-tree/" target="_blank" rel="noopener">109. 有序链表转换二叉搜索树</a></h4><p>给定一个单链表，其中的元素按升序排序，将其转换为高度平衡的二叉搜索树。</p><p>本题中，一个高度平衡二叉树是指一个二叉树<em>每个节点</em> 的左右两个子树的高度差的绝对值不超过 1。</p><p><strong>示例:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">给定的有序链表： [-10, -3, 0, 5, 9],</span><br><span class="line"></span><br><span class="line">一个可能的答案是：[0, -3, 9, -10, null, 5], 它可以表示下面这个高度平衡二叉搜索树：</span><br><span class="line"></span><br><span class="line">      0</span><br><span class="line">     &#x2F; \</span><br><span class="line">   -3   9</span><br><span class="line">   &#x2F;   &#x2F;</span><br><span class="line"> -10  5</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h2 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> mrzhang.leecode;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zhangnianlei</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/7/8</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 109. 有序链表转换二叉搜索树</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution109function3</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> ListNode head;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span>[] nums = &#123;-<span class="number">10</span>,-<span class="number">3</span>,<span class="number">0</span>,<span class="number">5</span>,<span class="number">9</span>, <span class="number">13</span>&#125;;</span><br><span class="line"><span class="comment">// 构建一个ListNode</span></span><br><span class="line">ListNode listNode = ListNode.getListNode(nums);</span><br><span class="line">Solution109function3 solution109 = <span class="keyword">new</span> Solution109function3();</span><br><span class="line">TreeNode root = solution109.sortedListToBST(listNode);</span><br><span class="line">TreeNode.prePrint(root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> leetcode 109 方法三 逆用中序遍历的思想：中序遍历二叉搜索树得到一个升序数列，那么反过来，使用此法将一个升序的数列构建成一个二叉搜索树</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zhangnianlei</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/7/9</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@exception</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>: node</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>: mrzhang.leecode.TreeNode</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@modifier</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> TreeNode <span class="title">sortedListToBST</span><span class="params">(ListNode node)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 计算listNode的长度</span></span><br><span class="line"><span class="keyword">int</span> size = countListNodeSize(node);</span><br><span class="line"><span class="comment">// 使用全局的ListNode变量协助</span></span><br><span class="line">head = node;</span><br><span class="line"><span class="comment">// 构建二叉搜索树</span></span><br><span class="line"><span class="keyword">return</span> convertListToBST(<span class="number">0</span>, size - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 计算listNode的长度</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zhangnianlei</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/7/11</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@exception</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>: left</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>: right</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>: mrzhang.leecode.TreeNode</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@modifier</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> TreeNode <span class="title">convertListToBST</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (right &lt; left) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">int</span> mid = (right + left) / <span class="number">2</span>;</span><br><span class="line">TreeNode leftNode = convertListToBST(left, mid - <span class="number">1</span>);</span><br><span class="line">TreeNode result = <span class="keyword">new</span> TreeNode(head.val);</span><br><span class="line">result.left = leftNode;</span><br><span class="line">head = head.next;</span><br><span class="line">result.right = convertListToBST(mid + <span class="number">1</span>, right);</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 计算listNode的长度</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zhangnianlei</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/7/11</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@exception</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>: head</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>: int</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@modifier</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">countListNodeSize</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (head == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">ListNode p = head;</span><br><span class="line"><span class="keyword">while</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">sum += <span class="number">1</span>;</span><br><span class="line">p = p.next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更多详细代码见我的代码仓库</p><p><a href="https://github.com/ZhangnLei/java-base/tree/master/src/main/java/mrzhang/leecode" target="_blank" rel="noopener">https://github.com/ZhangnLei/java-base/tree/master/src/main/java/mrzhang/leecode</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[toc]&lt;/p&gt;
&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;h4 id=&quot;109-有序链表转换二叉搜索树&quot;&gt;&lt;a href=&quot;#109-有序链表转换二叉搜索树&quot; class=&quot;h
      
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="快慢指针" scheme="http://yoursite.com/tags/%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88/"/>
    
      <category term="二叉搜索树" scheme="http://yoursite.com/tags/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
    
      <category term="递归" scheme="http://yoursite.com/tags/%E9%80%92%E5%BD%92/"/>
    
      <category term="中序遍历" scheme="http://yoursite.com/tags/%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 876. 获取链表的中间结点</title>
    <link href="http://yoursite.com/2020/07/07/LeetCode-876-%E8%8E%B7%E5%8F%96%E9%93%BE%E8%A1%A8%E7%9A%84%E4%B8%AD%E9%97%B4%E7%BB%93%E7%82%B9/"/>
    <id>http://yoursite.com/2020/07/07/LeetCode-876-获取链表的中间结点/</id>
    <published>2020-07-07T07:06:44.000Z</published>
    <updated>2020-07-11T05:05:04.636Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><h4 id="876-链表的中间结点"><a href="#876-链表的中间结点" class="headerlink" title="876. 链表的中间结点"></a><a href="https://leetcode-cn.com/problems/middle-of-the-linked-list/" target="_blank" rel="noopener">876. 链表的中间结点</a></h4><p>给定一个带有头结点 <code>head</code> 的非空单链表，返回链表的中间结点。</p><p>如果有两个中间结点，则返回第二个中间结点。</p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：[1,2,3,4,5]</span><br><span class="line">输出：此列表中的结点 3 (序列化形式：[3,4,5])</span><br><span class="line">返回的结点值为 3 。 (测评系统对该结点序列化表述是 [3,4,5])。</span><br><span class="line">注意，我们返回了一个 ListNode 类型的对象 ans，这样：</span><br><span class="line">ans.val &#x3D; 3, ans.next.val &#x3D; 4, ans.next.next.val &#x3D; 5, 以及 ans.next.next.next &#x3D; NULL.</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：[1,2,3,4,5,6]</span><br><span class="line">输出：此列表中的结点 4 (序列化形式：[4,5,6])</span><br><span class="line">由于该列表有两个中间结点，值分别为 3 和 4，我们返回第二个结点。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>给定链表的结点数介于 <code>1</code> 和 <code>100</code> 之间。</li></ul><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>快慢指针的思想：快指针一次移动2个，慢指针一次移动一个，则快指针到末尾时，慢指针刚好在中间。</p><h2 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">middleNode</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">ListNode fast = head;</span><br><span class="line">ListNode slow = head;</span><br><span class="line"><span class="keyword">while</span> (fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">slow = slow.next;</span><br><span class="line">fast = fast.next.next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更多详细代码见我的代码仓库</p><p><a href="https://github.com/ZhangnLei/java-base/tree/master/src/main/java/mrzhang/leecode" target="_blank" rel="noopener">https://github.com/ZhangnLei/java-base/tree/master/src/main/java/mrzhang/leecode</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;h4 id=&quot;876-链表的中间结点&quot;&gt;&lt;a href=&quot;#876-链表的中间结点&quot; class=&quot;headerlink&quot; title=&quot;876
      
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="链表" scheme="http://yoursite.com/tags/%E9%93%BE%E8%A1%A8/"/>
    
      <category term="快慢指针" scheme="http://yoursite.com/tags/%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>我的偶像</title>
    <link href="http://yoursite.com/2020/05/18/%E6%88%91%E7%9A%84%E5%81%B6%E5%83%8F/"/>
    <id>http://yoursite.com/2020/05/18/我的偶像/</id>
    <published>2020-05-18T05:26:05.000Z</published>
    <updated>2020-05-18T05:43:45.608Z</updated>
    
    <content type="html"><![CDATA[<p>@auther <code>张念磊</code><br>@date <code>2020/5/18</code></p><p>[toc]</p><h1 id="我的偶像："><a href="#我的偶像：" class="headerlink" title="我的偶像："></a>我的偶像：</h1><p>对我影响很深的两个人 一个是篮球巨星 - 科比，另一个是苹果的创始人CEO - 乔布斯。</p><p>我喜欢他们的基础是我对他们非常的了解，越了解越能发现他们身上的闪光点，就越喜欢越欣赏。</p><p>我在我的高中时代读了《乔布斯传》，每天晚上在被窝里拿着一个砸脸很痛的MP4，劣质的屏幕、刺眼的光，我永远忘不了那个时候读到激动处全身的颤抖。 </p><p>我不知道你是否了解科比？单纯的觉得他就是努力的代名词。科比非常的聪明，当然他也足够简单、执着。</p><p>你可能听过他说的“凌晨四点的洛杉矶”，但他并不是从凌晨四点开始一直训练练到晚上。他的时间安排精力管理能力都非常的惊人，让我受益良多。</p><h2 id="科比"><a href="#科比" class="headerlink" title="科比"></a>科比</h2><p>（你不需要喜欢打篮球，也不需要看篮球比赛。因为你知道的我也不是多喜欢篮球，我只是单纯的喜欢科比这个人，还有他的曼巴精神）</p><p>视频链接1：<a href="https://www.bilibili.com/video/BV1bs411W78y?t=971" target="_blank" rel="noopener">【科比TED:意志的力量】科比的意志力到底有多强?</a></p><h3 id="科比给我的启示"><a href="#科比给我的启示" class="headerlink" title="科比给我的启示"></a>科比给我的启示</h3><h4 id="科比的曼巴精神"><a href="#科比的曼巴精神" class="headerlink" title="科比的曼巴精神"></a>科比的曼巴精神</h4><p>令我着迷，当然也充满了好奇，他是如何保持如此持久的激情和热爱。</p><h4 id="面对问题时的态度"><a href="#面对问题时的态度" class="headerlink" title="面对问题时的态度"></a>面对问题时的态度</h4><p>不放弃尝试的权利。因为做和不做的差别太大了：</p><ol><li>体验，做了才有资格评论；</li><li>成长，去做一件事情肯定是先了解原理，然后实践，最后总结。如果你做都不去做，连原理都不了解，那就对这一块永远都不了解，所以尝试最差的结果也是收获知识，填补知识盲区。</li><li>一旦开始做了，就相信自己一定做到。只有这样才能让自己全力以赴。想尽办法、详细的规划、问题分为几个阶段，然后一个阶段一个阶段的去完成。同时每一阶段都专注于这一阶段该干的事情。</li></ol><h4 id="精力和时间管理的方法"><a href="#精力和时间管理的方法" class="headerlink" title="精力和时间管理的方法"></a>精力和时间管理的方法</h4><p>时间是有限的，精力也是。一定是把最好的状态给到最重要的事情。</p><p>对此，我有很多自己的小方法：晚上会找好第二天穿的衣服，这样第二天早上就不用思考这种穿衣问题。</p><p>同样的原理，安排琐碎的事情也可以用同样的方法：比如三餐吃什么，我会用随机软件（小程序），减少决策的成本。</p><p>视频链接2：<a href="https://mp.weixin.qq.com/mp/homepage?__biz=MzU5Njg1NDM3MA==&amp;hid=6&amp;sn=180ee10244a8b361b6e34eeaa0765fb6&amp;scene=1&amp;devicetype=Windows+10&amp;version=6208006f&amp;lang=zh_CN&amp;nettype=3G+&amp;ascene=14&amp;session_us=gh_d6035a7f6d1b&amp;fontScale=100&amp;pass_ticket=4bRFG6BWD6D%2BlLn7Y%2BStzxpIKS5qyObsQELGzsKm%2FRNqvPYNO6%2BO1kiqynCJZfCP&amp;wx_header=1&amp;uin=MzAzODA4MjkxMg%3D%3D&amp;key=1fb1a3c108c4a26cdcebd4933f7a2866a0c11c0bb4d9f5416ffb860c343a805fc2541a856dc15d9d06293cc660edd8eb9c8e834b9116fc0864919b7797ec209d157ad77b4f91f0f50b5ea2e6f4dcaf50" target="_blank" rel="noopener">【第四个视频】迈克尔·乔丹落泪深情缅怀科比：你走了，一部分我也死了</a></p><p>【视频链接2中的第一个视频】：总是逃避各种事情？心理学家：别藏了，你比想象的更强大</p><p>视频链接3： <a href="https://www.bilibili.com/video/BV1i7411v7PF?t=611" target="_blank" rel="noopener">解读《被讨厌的勇气》学习阿德勒的人生哲学！</a></p><p> 关于梦想，关于使命感</p><h2 id="乔布斯"><a href="#乔布斯" class="headerlink" title="乔布斯"></a>乔布斯</h2><p>视频链接4：<a href="https://www.bilibili.com/video/BV1oW411h7Ea/?spm_id_from=333.788.videocard.0" target="_blank" rel="noopener">乔布斯在斯坦福大学毕业典礼上的演讲</a></p><blockquote><p>If you haven’t found it yet, keep looking, and don’t settle.<br>你们如果还没有发现自己喜欢什么，那就不断地去寻找，不要祈求安逸</p></blockquote><p>以下为两段摘抄 - 链接： <a href="http://www.zhangnlei.cn/article/61" target="_blank" rel="noopener">http://www.zhangnlei.cn/article/61</a></p><h1 id="如何做梦"><a href="#如何做梦" class="headerlink" title="如何做梦"></a>如何做梦</h1><p> “梦 - Lil Jet”  18岁的rapper也可以有自己的梦，这首歌表达出的便是他自己的梦。</p><p>我们不评判这个梦的大小，高尚与否，关键是：有了梦，生活工作才有灵魂。</p><h2 id="我对于梦想的追寻"><a href="#我对于梦想的追寻" class="headerlink" title="我对于梦想的追寻"></a>我对于梦想的追寻</h2><p>乔布斯的演讲中的一句话：<code>If you haven&#39;t found it yet, keep looking, and don&#39;t settle.</code> 是如何拥有梦想这个问题最好解答。</p><p>我给自己找了一个梦想，35岁，40岁，，</p><p>我在35岁40岁后面加的是逗号，那个东西不是我梦想的终结，更不是我人生的终结。人生是一场修炼，我的使命感让我觉的我要做的远不止于此，但是那是我当前想到的最伟大的梦想了。</p><h2 id="很具体的东西"><a href="#很具体的东西" class="headerlink" title="很具体的东西"></a>很具体的东西</h2><p>孔老夫子：修身齐家治国平天下，修身而后齐家，齐家而后治国，治国而后平天下。这是一个递进的关系，所以我没有办法在自己都没修炼好的时候就想着影响其他的人，因为我不知会把人往好的方向引导还是坏的方向引导。</p><p>所以据其位谋其事，我当前就是在修身的阶段。</p><p>我觉得梦想是非常珍贵的东西。他有很多作用，比方说梦想可以<code>持续</code>的激励我，激励我变强，激励我广博的获取知识，持续学习，保持初心。</p><p>他可以让我更容易管理我自己，看什么样的书，交什么样的朋友</p><p>当然有助于我做选择，我现在的选择标准很简单，如果这件事情有助于我梦想的实现，能让我离我的梦想更进一步，那我就义无反顾的去做。不用过多的纠结利弊分析，先做了再说。</p><h2 id="我的方法论"><a href="#我的方法论" class="headerlink" title="我的方法论"></a>我的方法论</h2><p> “想成为什么样的人，那就先做他做的事。” 这是我追梦的方法。当然要抓住本质，不能只学表面，东施效颦，得不偿失。</p><h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>以上便是我近几年来对于梦想、对于修炼的看法。 如果能对你找到梦想有一点帮助，便很开心了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;@auther &lt;code&gt;张念磊&lt;/code&gt;&lt;br&gt;@date &lt;code&gt;2020/5/18&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;[toc]&lt;/p&gt;
&lt;h1 id=&quot;我的偶像：&quot;&gt;&lt;a href=&quot;#我的偶像：&quot; class=&quot;headerlink&quot; title=&quot;我的偶像：
      
    
    </summary>
    
    
      <category term="偶像" scheme="http://yoursite.com/tags/%E5%81%B6%E5%83%8F/"/>
    
      <category term="科比" scheme="http://yoursite.com/tags/%E7%A7%91%E6%AF%94/"/>
    
      <category term="乔布斯" scheme="http://yoursite.com/tags/%E4%B9%94%E5%B8%83%E6%96%AF/"/>
    
      <category term="梦想" scheme="http://yoursite.com/tags/%E6%A2%A6%E6%83%B3/"/>
    
      <category term="修炼" scheme="http://yoursite.com/tags/%E4%BF%AE%E7%82%BC/"/>
    
  </entry>
  
  <entry>
    <title>前端技术 - 查询搜索时的防抖</title>
    <link href="http://yoursite.com/2020/05/18/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF-%E6%9F%A5%E8%AF%A2%E6%90%9C%E7%B4%A2%E6%97%B6%E7%9A%84%E9%98%B2%E6%8A%96/"/>
    <id>http://yoursite.com/2020/05/18/前端技术-查询搜索时的防抖/</id>
    <published>2020-05-18T04:49:30.000Z</published>
    <updated>2020-05-18T05:07:24.684Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> queryUserByChunk(search) &#123;</span><br><span class="line">  clearTimeout(<span class="keyword">this</span>.timeout) <span class="comment">// this.timeout 是一个全局变量</span></span><br><span class="line">  <span class="keyword">let</span> param = &#123;</span><br><span class="line">    corporationNo: localStorage.getItem(<span class="string">"orgAcct"</span>),</span><br><span class="line">    searchParam: search</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">this</span>.timeout = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    findUserByUsernameOrRealNameOrJobNo(param)</span><br><span class="line">      .then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// do some thing...</span></span><br><span class="line">      &#125;)</span><br><span class="line">      .catch(<span class="function"><span class="params">error</span> =&gt;</span> &#123;&#125;);</span><br><span class="line">  &#125;, <span class="number">300</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;l
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>为什么说爱抱怨、喜欢找借口的人往往一事无成？《被讨厌的勇气》 - 阿德勒的人生哲学！ </title>
    <link href="http://yoursite.com/2020/05/14/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%AF%B4%E7%88%B1%E6%8A%B1%E6%80%A8%E3%80%81%E5%96%9C%E6%AC%A2%E6%89%BE%E5%80%9F%E5%8F%A3%E7%9A%84%E4%BA%BA%E5%BE%80%E5%BE%80%E4%B8%80%E4%BA%8B%E6%97%A0%E6%88%90%EF%BC%9F%E3%80%8A%E8%A2%AB%E8%AE%A8%E5%8E%8C%E7%9A%84%E5%8B%87%E6%B0%94%E3%80%8B-%E9%98%BF%E5%BE%B7%E5%8B%92%E7%9A%84%E4%BA%BA%E7%94%9F%E5%93%B2%E5%AD%A6%EF%BC%81/"/>
    <id>http://yoursite.com/2020/05/14/为什么说爱抱怨、喜欢找借口的人往往一事无成？《被讨厌的勇气》-阿德勒的人生哲学！/</id>
    <published>2020-05-14T05:03:36.000Z</published>
    <updated>2020-05-14T05:07:21.706Z</updated>
    
    <content type="html"><![CDATA[<p>发现名人自传、访谈中那些人很少抱怨，很少找借口，在自己的领域做出成就。</p><h3 id="为什么"><a href="#为什么" class="headerlink" title="为什么"></a>为什么</h3><p>而大多数人都喜欢推卸责任，因为人会有推卸责任的习惯，会找那些经历来解释当前的状态，把过去搬出来解释自己现在，把不幸当成自己的借口，推卸自己的责任</p><h3 id="怎么做"><a href="#怎么做" class="headerlink" title="怎么做"></a>怎么做</h3><p>没有必要把活着的经历去纠结那些完全无法改变的事，但是我们完全有能力去改变现在呀，从而去影响明天。</p><p>阿德勒认为，我们成年后，就要为自己的行为负责，为自己的人生负责。</p><p>我们每时每刻都在做选择，读什么样的书？看什么样的剧？听什么样的歌？关注哪些人？和谁去结婚？做什么样的职业？甚至每天的时间是如何安排的？精力主要用在了什么地方？</p><p>这一切都是自己的选择，是自己一次又一次的义无反顾的选择，把你送到了现在的位置、达到了现在的状态。</p><p>无需抱怨自己拿到了什么样牌，而是考虑如何打好现有的牌，这才是务实有建设性人生态度。</p><p>没有谁的人生是完美后才出发的</p><p><code>承认自己的不足需要勇气，但这也是进步的开始。</code></p><p>原视频</p><p><a href="https://www.bilibili.com/video/BV1i7411v7PF" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1i7411v7PF</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;发现名人自传、访谈中那些人很少抱怨，很少找借口，在自己的领域做出成就。&lt;/p&gt;
&lt;h3 id=&quot;为什么&quot;&gt;&lt;a href=&quot;#为什么&quot; class=&quot;headerlink&quot; title=&quot;为什么&quot;&gt;&lt;/a&gt;为什么&lt;/h3&gt;&lt;p&gt;而大多数人都喜欢推卸责任，因为人会有推卸责任的
      
    
    </summary>
    
    
      <category term="《被讨厌的勇气》" scheme="http://yoursite.com/tags/%E3%80%8A%E8%A2%AB%E8%AE%A8%E5%8E%8C%E7%9A%84%E5%8B%87%E6%B0%94%E3%80%8B/"/>
    
      <category term="阿德勒" scheme="http://yoursite.com/tags/%E9%98%BF%E5%BE%B7%E5%8B%92/"/>
    
  </entry>
  
  <entry>
    <title>程序员高效学习英语的方法</title>
    <link href="http://yoursite.com/2020/05/14/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%AB%98%E6%95%88%E5%AD%A6%E4%B9%A0%E8%8B%B1%E8%AF%AD%E7%9A%84%E6%96%B9%E6%B3%95/"/>
    <id>http://yoursite.com/2020/05/14/程序员高效学习英语的方法/</id>
    <published>2020-05-14T04:19:52.000Z</published>
    <updated>2020-05-14T05:48:41.117Z</updated>
    
    <content type="html"><![CDATA[<p>@auther <code>张念磊</code><br>@date <code>2020/5/14</code></p><p>[toc]</p><h1 id="为什么学英语？"><a href="#为什么学英语？" class="headerlink" title="为什么学英语？"></a>为什么学英语？</h1><p>我的需求：</p><ol><li><p>看英文视频 （教程 发布会）</p></li><li><p>读英文文章 （技术教程、官方文档）</p></li></ol><h1 id="如何高效的学习英语？"><a href="#如何高效的学习英语？" class="headerlink" title="如何高效的学习英语？"></a>如何高效的学习英语？</h1><ol><li>首先开始学习（学习方法）</li><li>坚持（<code>重中之重</code>）</li><li>日常生活中使用英语（看英文视频、看英文文章。慢慢使用英语，成为工具）</li></ol><h2 id="步骤一：开始学习"><a href="#步骤一：开始学习" class="headerlink" title="步骤一：开始学习"></a>步骤一：开始学习</h2><p>学习有非常多中方法，下面介绍一下我的几种方法</p><h3 id="方法1："><a href="#方法1：" class="headerlink" title="方法1："></a>方法1：</h3><p>使用网站 <a href="https://bdc.youzack.com/" target="_blank" rel="noopener">https://bdc.youzack.com/</a></p><ul><li><p>先背单词</p></li><li><p>再阅读文章</p></li></ul><p><code>解释</code>：如果我想阅读一篇文章，但是有很多的生词不认识，一遍查一边读效率非常差，很容易放弃。</p><p>这个网站有一个功能，就是你把你自己要读的文章上传上去，然后他会生成一个单词本，我们背这个单词本。单词本会把<code>词频最高</code>的单词放在最前面，让我们先背，出现次数低的后面再背，这样背完，再去读那篇文章。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gerxg8kp6nj30ni0eg0uo.jpg" alt="image-20200514134453128"></p><p>有几个优点：</p><p>有<code>针对性</code>、<code>目的性</code>的背单词，效率会很高；</p><p>读文章时会发现，哎，这个单词我背过，会有很好的<code>正反馈</code>和<code>成就感</code>。</p><blockquote><p> 成就感 == 多巴胺 == 快乐</p></blockquote><p>网站的前端非常简单，但是五脏俱全</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gerxj4fmooj30ng0mlt9w.jpg" alt="image-20200514134739216"></p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gerxjg8tosj30ng0ml40k.jpg" alt="image-20200514134759002"></p><ul><li>学习听力</li></ul><p>使用网站 <a href="https://bdc.youzack.com/" target="_blank" rel="noopener">https://bdc.youzack.com/</a></p><p>反复练习每一句。</p><p>// todo 详细介绍</p><h3 id="方法2："><a href="#方法2：" class="headerlink" title="方法2："></a>方法2：</h3><p>马思睿 - B站</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gerx0znvu1j30yx0kmdk3.jpg" alt="image-20200514122513250"></p><p>分享的资源网站：ted.com</p><p>复读机App:</p><p>iPhone SpeaterLite</p><p>Android KMPlayer</p><p>下载字幕:</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gerv1w0cp7j30z50krtrz.jpg" alt="image-20200514122154095"></p><p>播客</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gerv3tj49hj30yy0km19t.jpg" alt="image-20200514122341766"></p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gerv4ibn0vj30yx0kknea.jpg" alt="image-20200514122423957"></p><h2 id="步骤二：坚持"><a href="#步骤二：坚持" class="headerlink" title="步骤二：坚持"></a>步骤二：坚持</h2><p>// todo 如何坚持，自我激励</p><h2 id="步骤三：使用（看英文视频，看英文文章）"><a href="#步骤三：使用（看英文视频，看英文文章）" class="headerlink" title="步骤三：使用（看英文视频，看英文文章）"></a>步骤三：使用（看英文视频，看英文文章）</h2><p>推荐网站 / App:  Medium</p><p>// todo 详细写一点</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;@auther &lt;code&gt;张念磊&lt;/code&gt;&lt;br&gt;@date &lt;code&gt;2020/5/14&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;[toc]&lt;/p&gt;
&lt;h1 id=&quot;为什么学英语？&quot;&gt;&lt;a href=&quot;#为什么学英语？&quot; class=&quot;headerlink&quot; title=&quot;为
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>清单革命 - 怎样使清单更有效？</title>
    <link href="http://yoursite.com/2020/05/13/%E6%B8%85%E5%8D%95%E9%9D%A9%E5%91%BD-%E6%80%8E%E6%A0%B7%E4%BD%BF%E6%B8%85%E5%8D%95%E6%9B%B4%E6%9C%89%E6%95%88%EF%BC%9F/"/>
    <id>http://yoursite.com/2020/05/13/清单革命-怎样使清单更有效？/</id>
    <published>2020-05-13T00:45:41.000Z</published>
    <updated>2020-05-13T01:58:04.417Z</updated>
    
    <content type="html"><![CDATA[<h1 id="清单革命-怎样使清单更有效？"><a href="#清单革命-怎样使清单更有效？" class="headerlink" title="清单革命 - 怎样使清单更有效？"></a>清单革命 - 怎样使清单更有效？</h1><p>@auther <code>张念磊</code><br>@date <code>2020/5/13</code></p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1geqklx050gj314x0u0q9u.jpg" alt="清单革命导图"></p><p>[toc]</p><h2 id="零、前言"><a href="#零、前言" class="headerlink" title="零、前言"></a>零、前言</h2><p><code>TODO</code> 引用一句</p><blockquote><p>金融巨头曾经说过，他之所以能比其他人投资更成功，不仅仅因为他有正确的决策，还有一个很重要的原因就是他能够避免犯一些愚蠢的错误。</p></blockquote><p>作者：阿图.葛文德 《时代周刊》“全球100位影响力人物”榜单的唯一一名医生</p><p>一张手术清单，让原本经常发生的手术感染率从11%下降到0；</p><h2 id="一、人为什么会犯错？"><a href="#一、人为什么会犯错？" class="headerlink" title="一、人为什么会犯错？"></a>一、人为什么会犯错？</h2><p>人的错误可以分为两种：一种是无知之错，一种是无能之错。</p><p>无知之错，说的是因为没有掌握正确的知识， 没有相关的常识犯的错。</p><p>无能之错，说的是虽然掌握的正确的知识，但是没有正确的使用而犯下的错。</p><p>比如飞行员知道起飞前的所有程序，但是起飞前一个事情忘记做一个操作导致飞机失事。</p><p>工作生活中的无能之错：开会记错时间、</p><h2 id="二、为什么要使用清单？"><a href="#二、为什么要使用清单？" class="headerlink" title="二、为什么要使用清单？"></a>二、为什么要使用清单？</h2><h3 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h3><p><code>规避错误</code></p><p>发挥作用的两点原因：</p><p>1）把大脑不擅长的记忆工作外包下来</p><p>2）清单更可靠，通过可视化和强限制性执行来确保完成度</p><h3 id="使用清单的好处？"><a href="#使用清单的好处？" class="headerlink" title="使用清单的好处？"></a>使用清单的好处？</h3><p>避免无能之错</p><p>清单是如何避免无能之错？</p><p>执行清单 解决简单问题</p><p>核查清单 应对复杂问题</p><p>沟通清单 应对不确定性的复杂问题</p><h2 id="三、如何使用清单？"><a href="#三、如何使用清单？" class="headerlink" title="三、如何使用清单？"></a>三、如何使用清单？</h2><h3 id="制定"><a href="#制定" class="headerlink" title="制定"></a>制定</h3><p><code>制定清单的原则</code>：</p><p> <strong>1.</strong> <strong>简单高效可测</strong></p><p> <strong>2.</strong> <strong>设置明确的检查点</strong></p><p> 设置时间：</p><ol><li><p>前</p></li><li><p>中</p></li><li><p>后</p></li><li><p>意外发生时</p><p><strong>3.</strong> <strong>及时更新清单</strong></p></li></ol><h3 id="执行"><a href="#执行" class="headerlink" title="执行"></a>执行</h3><p>参考：</p><p><code>得到App 每天听本书 - 《清单革命》</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;清单革命-怎样使清单更有效？&quot;&gt;&lt;a href=&quot;#清单革命-怎样使清单更有效？&quot; class=&quot;headerlink&quot; title=&quot;清单革命 - 怎样使清单更有效？&quot;&gt;&lt;/a&gt;清单革命 - 怎样使清单更有效？&lt;/h1&gt;&lt;p&gt;@auther &lt;code&gt;张念磊&lt;
      
    
    </summary>
    
    
      <category term="清单" scheme="http://yoursite.com/tags/%E6%B8%85%E5%8D%95/"/>
    
  </entry>
  
  <entry>
    <title>后端开发 - SpringBoot项目名中如何处理service层的异常？</title>
    <link href="http://yoursite.com/2020/05/04/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91-SpringBoot%E9%A1%B9%E7%9B%AE%E5%90%8D%E4%B8%AD%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86service%E5%B1%82%E7%9A%84%E5%BC%82%E5%B8%B8%EF%BC%9F/"/>
    <id>http://yoursite.com/2020/05/04/后端开发-SpringBoot项目名中如何处理service层的异常？/</id>
    <published>2020-05-04T03:07:19.000Z</published>
    <updated>2020-05-05T09:14:53.181Z</updated>
    
    <content type="html"><![CDATA[<h1 id="后端开发-SpringBoot项目名中如何处理service层的异常？"><a href="#后端开发-SpringBoot项目名中如何处理service层的异常？" class="headerlink" title="后端开发 - SpringBoot项目名中如何处理service层的异常？"></a>后端开发 - SpringBoot项目名中如何处理service层的异常？</h1><p>[toc]</p><p>先说自己犯的错误：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 非常一长串逻辑代码</span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">...</span><br><span class="line">    ...</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">logger.error(<span class="string">"&gt;&gt;&gt;className.methodsName,异常原因：&#123;&#125;"</span>, e.getMessage());</span><br><span class="line"><span class="keyword">return</span> CommonMsgUtils.getErrorCommonMsg(commonMsg, ErrorCodeEnum.DATABASE_EXCEPTION);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>阿里巴巴编码规范 第二章 - 异常处理：</p><blockquote><p>/3. 【强制】catch 时请分清稳定代码和非稳定代码，稳定代码指的是无论如何不会出错的代码。 对于非稳定代码的 catch 尽可能进行区分异常类型，再做对应的异常处理。 说明:对大段代码进行 try-catch，使程序无法根据不同的异常做出正确的应激反应，也不利 于定位问题，这是一种不负责任的表现。 正例:用户注册的场景中，如果用户输入非法字符，或用户名称已存在，或用户输入密码过于 简单，在程序上作出分门别类的判断，并提示给用户。</p></blockquote><blockquote><p>/4. 【强制】捕获异常是为了处理它，不要捕获了却什么都不处理而抛弃之，如果不想处理它，请 将该异常抛给它的调用者。最外层的业务使用者，必须处理异常，将其转化为用户可以理解的 内容。</p></blockquote><blockquote><p>/5. 【强制】有 try 块放到了事务代码中，catch 异常后，如果需要回滚事务，一定要注意手动回 滚事务。</p></blockquote><blockquote><p>/6)  级联调用obj.getA().getB().getC();一连串调用，易产生NPE。</p><p>正例:使用 JDK8 的 Optional 类来防止 NPE 问题。</p></blockquote><p>日志：</p><blockquote><p>/4. 【强制】对 trace/debug/info 级别的日志输出，必须使用条件输出形式或者使用占位符的方 式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//说明(反例):</span></span><br><span class="line">logger.debug(<span class="string">"Processing trade with id: "</span> + id + <span class="string">" and symbol: "</span> + symbol);</span><br></pre></td></tr></table></figure><p> 如果日志级别是 warn，上述日志不会打印，但是会执行字符串拼接操作，如果 symbol 是对象， 会执行 toString()方法，浪费了系统资源，执行了上述操作，最终日志却没有打印。 </p><p>建设采用如下方式:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正例1:(条件)</span></span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">"Processing trade with id: "</span> + id + <span class="string">" and symbol: "</span> + symbol);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正例2:(占位符)</span></span><br><span class="line">logger.debug(<span class="string">"Processing trade with id: &#123;&#125; and symbol : &#123;&#125; "</span>, id, symbol);</span><br></pre></td></tr></table></figure></blockquote><p>参考：</p><p><a href="https://www.cnblogs.com/gujiazhouwang/p/12028713.html" target="_blank" rel="noopener">https://www.cnblogs.com/gujiazhouwang/p/12028713.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;后端开发-SpringBoot项目名中如何处理service层的异常？&quot;&gt;&lt;a href=&quot;#后端开发-SpringBoot项目名中如何处理service层的异常？&quot; class=&quot;headerlink&quot; title=&quot;后端开发 - SpringBoot项目名中如
      
    
    </summary>
    
    
      <category term="springboot" scheme="http://yoursite.com/tags/springboot/"/>
    
      <category term="异常处理" scheme="http://yoursite.com/tags/%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>使用脚本解放双手 - 批量更新git分支</title>
    <link href="http://yoursite.com/2020/04/29/%E4%BD%BF%E7%94%A8%E8%84%9A%E6%9C%AC%E8%A7%A3%E6%94%BE%E5%8F%8C%E6%89%8B-%E6%89%B9%E9%87%8F%E6%9B%B4%E6%96%B0git%E5%88%86%E6%94%AF/"/>
    <id>http://yoursite.com/2020/04/29/使用脚本解放双手-批量更新git分支/</id>
    <published>2020-04-29T01:42:09.000Z</published>
    <updated>2020-04-29T02:29:35.754Z</updated>
    
    <content type="html"><![CDATA[<h1 id="使用脚本批量更新git分支"><a href="#使用脚本批量更新git分支" class="headerlink" title="使用脚本批量更新git分支"></a>使用脚本批量更新git分支</h1><p>@auther <code>张念磊</code><br>@date <code>2020/4/29</code></p><p>[toc]</p><h3 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h3><p>使用脚本，解放双手</p><h3 id="先上代码"><a href="#先上代码" class="headerlink" title="先上代码"></a>先上代码</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">function readfile ()</span><br><span class="line">&#123;</span><br><span class="line"> for file in `ls $1`</span><br><span class="line"> do</span><br><span class="line"><span class="meta">#</span><span class="bash"> 判断是否是文件夹，如果是文件夹则删除文件夹中的 dev <span class="built_in">test</span> release 分支</span></span><br><span class="line"> if [ -d $1"/"$file ]</span><br><span class="line"> then</span><br><span class="line">  cd $&#123;file&#125;</span><br><span class="line">  pwd</span><br><span class="line">  git checkout master;</span><br><span class="line">  git branch -D dev; git branch -D test; git branch -D release;</span><br><span class="line"><span class="meta">  #</span><span class="bash"> git checkout master; git pull;</span></span><br><span class="line">  cd ..</span><br><span class="line"> fi</span><br><span class="line"> done</span><br><span class="line">&#125;</span><br><span class="line">readfile "./"</span><br><span class="line"></span><br><span class="line">echo '完美的运行！'</span><br></pre></td></tr></table></figure><p>代码思路：</p><ol><li>for循环遍历当前文件夹下的文件</li><li>判断每个文件的类型是否是文件夹</li><li>如果是文件夹则进入该文件夹中，</li><li>切换master分支，避免下面一步时删除分支失败（git 删除分支时是不能删除当前所在的分支的，例如 当前在dev分支，执行git branch -D dev 时会提示Cannot delete branch ‘dev’…）</li><li>删除文件夹中的 dev test release 分支</li><li>最后打印运行结束</li></ol><h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><ol><li>准备shell<ol><li>新建文本文档，将以上代码copy进来，保存命名为<code>clear-git-branch.sh</code> 一定要以<code>.sh</code>为文件后缀</li><li>将文件放在需要批量更新代码的文件夹中</li></ol></li></ol><p>文件结构大概长这样：</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1geaeceaslhj30ty0h6q7s.jpg" alt="image-20200429094911638"></p><ol start="2"><li><p>运行脚本</p><p><code>window平台：</code></p><p>​    方式1：双击运行shell脚本；</p><p>​    方式2：使用GitBash工具</p><p>​        先切换到存放代码的目录，然后执行代码：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./clear-git-branch.sh</span><br></pre></td></tr></table></figure><p><code>macOS或Linux平台：</code></p><p>需先给shell脚本添加执行的权限：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod +x clear-git-branch.sh</span><br></pre></td></tr></table></figure><p>然后运行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./clear-git-branch.sh</span><br></pre></td></tr></table></figure></li></ol><p>运行效果:<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ./clear-git-branch.sh</span></span><br><span class="line">/f/code/sycode/dcit-serxxxxxxxx</span><br><span class="line">Already on 'master'</span><br><span class="line">Your branch is up to date with 'origin/master'.</span><br><span class="line">Deleted branch dev (was 6c999e7).</span><br><span class="line">Deleted branch test (was a4238eb).</span><br><span class="line">Deleted branch release (was 6603884).</span><br><span class="line">Switched to a new branch 'dev'</span><br><span class="line">Branch 'dev' set up to track remote branch 'dev' from 'origin'.</span><br><span class="line">Switched to a new branch 'test'</span><br><span class="line">Branch 'test' set up to track remote branch 'test' from 'origin'.</span><br><span class="line">Switched to a new branch 'release'</span><br><span class="line">Branch 'release' set up to track remote branch 'release' from 'origin'.</span><br><span class="line">Switched to branch 'master'</span><br><span class="line">Your branch is up to date with 'origin/master'.</span><br><span class="line">....</span><br></pre></td></tr></table></figure></p><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ol><li><p>该脚本会把所有仓库的分支切换到master分支，如后续开发需要自己手动切回自己的特性分支。</p></li><li><p>可能会有失败的案例，当你的分支在dev/test/release且有正在编辑的代码，则会删除失败。</p></li></ol><p>对于这种情况需要自行判断是否保存并加以处理。</p><h3 id="大功告成"><a href="#大功告成" class="headerlink" title="大功告成"></a>大功告成</h3><p>完美，哈哈。</p><p>刚开始学习shell，有错误还请大佬指出。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;使用脚本批量更新git分支&quot;&gt;&lt;a href=&quot;#使用脚本批量更新git分支&quot; class=&quot;headerlink&quot; title=&quot;使用脚本批量更新git分支&quot;&gt;&lt;/a&gt;使用脚本批量更新git分支&lt;/h1&gt;&lt;p&gt;@auther &lt;code&gt;张念磊&lt;/code&gt;&lt;b
      
    
    </summary>
    
    
      <category term="shell" scheme="http://yoursite.com/tags/shell/"/>
    
      <category term="git" scheme="http://yoursite.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>后端开发 - 发现一个SQL的新技能</title>
    <link href="http://yoursite.com/2020/04/28/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91-%E5%8F%91%E7%8E%B0%E4%B8%80%E4%B8%AASQL%E7%9A%84%E6%96%B0%E6%8A%80%E8%83%BD/"/>
    <id>http://yoursite.com/2020/04/28/后端开发-发现一个SQL的新技能/</id>
    <published>2020-04-28T04:40:36.000Z</published>
    <updated>2020-04-28T05:07:40.032Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p> 不是发明创造，以前没见过这种用法，写下来记录一下。</p></blockquote><h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>需要写一个添加根据用户<code>真实姓名</code>或<code>用户名</code>或<code>工号</code>模糊查询用户信息的接口</p><p>但是公司用了<code>shardingjdbc</code>且是较低版本，不支持用 OR关键字，短时间内不可能将组件升级。</p><h2 id="怎么思路"><a href="#怎么思路" class="headerlink" title="怎么思路"></a>怎么思路</h2><p>使用concat() 函数</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">concat( real_name, '*', user_name, '*', work_no ) LIKE concat('%',#&#123;searchParam&#125;, '%' )</span><br></pre></td></tr></table></figure><p>哈哈，很简单，很神奇。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt; 不是发明创造，以前没见过这种用法，写下来记录一下。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;起因&quot;&gt;&lt;a href=&quot;#起因&quot; class=&quot;headerlink&quot; title=&quot;起因&quot;&gt;&lt;/a&gt;起因&lt;/h2&gt;&lt;p&gt;需要写一个添加根据
      
    
    </summary>
    
    
      <category term="SQL" scheme="http://yoursite.com/tags/SQL/"/>
    
  </entry>
  
  <entry>
    <title>MacOS笔记 - 下修改 MAC 地址</title>
    <link href="http://yoursite.com/2020/04/20/MacOS%E7%AC%94%E8%AE%B0-%E4%B8%8B%E4%BF%AE%E6%94%B9-MAC-%E5%9C%B0%E5%9D%80/"/>
    <id>http://yoursite.com/2020/04/20/MacOS笔记-下修改-MAC-地址/</id>
    <published>2020-04-20T01:28:00.000Z</published>
    <updated>2020-04-20T02:57:55.346Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MacOS笔记-下修改-MAC-地址"><a href="#MacOS笔记-下修改-MAC-地址" class="headerlink" title="MacOS笔记 - 下修改 MAC 地址"></a>MacOS笔记 - 下修改 MAC 地址</h1><p>在终端输入</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ifconfig en0 ether 00:00:00:00:00:00</span><br></pre></td></tr></table></figure><p>其中 en0 是你的第一块网卡（以太网卡，非无线），后面的 12 个 0 是要改成的目标网卡地址，输入以后会要求你输入管理员密码，别忘了给自己的账号先设定管理员密码，确认后当前机器的网卡地址会临时性生效，当重启后网卡地址又恢复成机器本身的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;MacOS笔记-下修改-MAC-地址&quot;&gt;&lt;a href=&quot;#MacOS笔记-下修改-MAC-地址&quot; class=&quot;headerlink&quot; title=&quot;MacOS笔记 - 下修改 MAC 地址&quot;&gt;&lt;/a&gt;MacOS笔记 - 下修改 MAC 地址&lt;/h1&gt;&lt;p&gt;在终
      
    
    </summary>
    
    
      <category term="MacOS" scheme="http://yoursite.com/tags/MacOS/"/>
    
      <category term="修改MAC地址" scheme="http://yoursite.com/tags/%E4%BF%AE%E6%94%B9MAC%E5%9C%B0%E5%9D%80/"/>
    
  </entry>
  
  <entry>
    <title>Vue - 如何在子组件中改变prop传入的值？</title>
    <link href="http://yoursite.com/2020/04/20/Vue-%E5%A6%82%E4%BD%95%E5%9C%A8%E5%AD%90%E7%BB%84%E4%BB%B6%E4%B8%AD%E6%94%B9%E5%8F%98prop%E4%BC%A0%E5%85%A5%E7%9A%84%E5%80%BC%EF%BC%9F/"/>
    <id>http://yoursite.com/2020/04/20/Vue-如何在子组件中改变prop传入的值？/</id>
    <published>2020-04-20T01:04:04.000Z</published>
    <updated>2020-04-20T01:24:42.406Z</updated>
    
    <content type="html"><![CDATA[<p>Vue - 如何在子组件中改变prop传入的值？</p><p> 我们都知道在vue中，父组件传入子组件的变量是存放在props属性中的，我们在调用变量的时候是跟data里面的变量一样的，都是通过this.变量来调用，但是如果想要在子组件中直接改变props中的属性浏览器会报错</p><p>如何解决这个问题呢？官方给出了一个方案(支持Vue2.3.0+)</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gdzyy9pn1yj30u00yqn6k.jpg" alt="image-20200420092057528"></p><p>参考：</p><p><a href="[https://cn.vuejs.org/v2/guide/components-custom-events.html#sync-%E4%BF%AE%E9%A5%B0%E7%AC%A6](https://cn.vuejs.org/v2/guide/components-custom-events.html#sync-修饰符">https://cn.vuejs.org/v2/guide/components…</a>)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Vue - 如何在子组件中改变prop传入的值？&lt;/p&gt;
&lt;p&gt; 我们都知道在vue中，父组件传入子组件的变量是存放在props属性中的，我们在调用变量的时候是跟data里面的变量一样的，都是通过this.变量来调用，但是如果想要在子组件中直接改变props中的属性浏览器会
      
    
    </summary>
    
    
      <category term="Vue" scheme="http://yoursite.com/tags/Vue/"/>
    
      <category term="prop" scheme="http://yoursite.com/tags/prop/"/>
    
      <category term="sync" scheme="http://yoursite.com/tags/sync/"/>
    
  </entry>
  
</feed>
